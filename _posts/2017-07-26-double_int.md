---
title: double转int丢失数据问题
date: 2017-07-26
categories: C++
---

今天在公司做OJ题的时候， 遇到了一个以前偶尔遇到
但是一直没有深究的问题。具体问题如下：

```c++
#include <iostream>
using namespace std;

int main()
{
    double a = 1.13;
	cout<<a<<endl;
    int b = (int)(a*100);
    cout<<b<<endl;
	return 0;
}
```

输出的结果为
```
1.13
112
```

由结果可以看出b的值为112而非113，为什么会造成这种结果？

首先我们需要看看浮点数在内存中的存储方式。
目前所有的C/C++编译器都是采用IEEE所制定的标准浮点数格式，即二进制科学表示法。在二进制科学表示法中，S=M*2^N主要是由三个部分组成：符号位+阶码(N)+尾数(M)。float和double中尾数和阶码的位数不一样，具体见下表。

数据类型 | 符号位 | 阶码 | 尾数
------- | ------ | ----- | ----
float	|  1	 |  8  |  23
double  |  1	| 11	| 52

*符号位：0表示正，1表示负*

**阶码**：使用移码表示，阶码有正有负，使用移码将负数表位正数，方便阶码的比较。对于float型数其规定的偏置量为127，表示范围为-128~127，如果移码采用128的话，在表达+127时会上溢（移码11111111被保留），但是127在表达-127时，会产生下溢（移码00000000被保留），所以阶码中去掉-127，-128，因此取值范围为-126~127，共254个值。double型规定为1023，其表示范围为-1024~1023。

**尾数**：有效数字为，即部分二进制位（小数点后面的二进制位），因为规定M的整数部分恒为1，所以这个1就进行存储了。

具体对于本例的1.13，其表示成科学记数法的话为1.13*2^0,阶码为0，double的移码为1023，因此阶码为01111111111，尾数部分十进制为0.13，将其转化为二进制（每次乘2，取整数部分，直到小数部分为0），将其转化后为0010000101000111101011100001010001111010111000010100，由此看出0.13并不能被精确的表示出来，这也是导致出现为题的根源。

因此我们在浮点数转整型时，应该时刻警惕这种问题。我在网上搜的解决方法，大多是使用+0.5或-0.5的方式来处理，但是这是计算四舍五入的方法，如果只是想截取整数呢？比如只是将double型的1.6,转成int型1呢，似乎这种无法得到我想要的，那应该如何正确的处理这种情况呢？这还有待我进一步去探索。

**参考资料**
[浅谈C/C++的浮点数在内存中的存储方式](http://www.cnblogs.com/dolphin0520/archive/2011/10/02/2198280.html)
[浮点数在计算机中存储方式](http://www.cnblogs.com/jillzhang/archive/2007/06/24/793901.html)
[【知乎】浮点数的表示为什么要用移码表示阶码？](https://www.zhihu.com/question/24115452)