---
tilte: C++11 新特性：堆内存管理--智能指针与垃圾回收
date: 2016-04-09
categories: C++
---

本文是对《深入理解C++11：C++11新特性解析与应用》的学习总结。

# 1. 显式内存管理

显式堆内存管理的常见的错误使用有：

1. 野指针：一些内存单元已被释放，之前指向它的指针却还在被使用。这些内存有可能被运行时系统重新分配给程序使用，从而导致了无法预测的错误。
2. 重复释放：程序试图去释放已经被释放过的内存单元，或者释放已经被重新分配过的内存单元，就会导致重复释放错误。通常重复释放内存会导致 C/C++ 运行时系统打印出大量错误及诊断信息。
3. 内存泄漏：不再需要使用的内存单元如果没有被释放就会导致内存泄漏。如果程序不断地重复进行这类操作，就将会导致内存占用剧增。

# 2. 智能指针

在 C++98 中，定义了一个智能指针 auto_ptr，但是 auto_ptr 有一些缺点，比如拷贝时返回一个左值，不能调用 delete[] 等。所以在 C++11 中改用 unique_ptr、share_ptr 和 weak_ptr 等智能指针来自动回收堆分配的对象。

下面这个程序将会说明 unique_ptr 和 share_ptr 的用法。

```c++
#include <iostream>
#include <memory>
using namespace std;

int main(){
	unique_ptr<int> up1(new int(11));
	unique_ptr<int> up2 = up1;		//不能通过编译
	cout<<*up1<<endl;

	unique_ptr<int> up3 = move(up1);	//现在 p3 是数据唯一的 unique_ptr 智能指针

	cout<<*up3<<endl;
	cout<<*up1<<endl;	//运行时错误
	up3.reset();	//显示释放内存
	up1.reset();	//不会导致错误
	cout<<*up3<<endl;	//运行时错误

	shared_ptr<int> sp1(new int(22));
	shared_ptr<int> sp2 = sp1;

	cout<<*sp1<<endl;
	cout<<*sp2<<endl;

	sp1.reset();
	cout<<*sp2<<endl;
	return 0;
}
```

从上面代码可以看出，unique_ptr 形如其名，与所指对象的内存绑定紧密，不能与其他 unique_ptr 类型的指针对象共享所指对象的内存，仅能通过标准库的 move 函数来转移。从实现上来讲，unique_ptr 则是一个删除了拷贝构造函数，保留了移动构造函数的指针封装类型。

而 shared_ptr 则允许多个该智能指针共享地“拥有”同一堆分配对象的内存。与 unique_ptr 不同的是，由于在实现上采用了引用计数，所以一旦一个 share_ptr 指针放弃了“所有权”，其他的 share_ptr 对对象内存的引用并不会收到影响。代码中调用 reset() 函数，只会导致引用计数的降低，不会导致堆内存的释放。只有在引用计数归零的时候，share_ptr 才会真正释放所占有的堆内存的空间。

而 weak_ptr 可以指向 share_ptr 指针指向的对象内存，却不拥有该内存，使用 weak_ptr 成员 lock，则可返回指向内存的一个 share_ptr 对象，且在所指对象内存已经无效时，返回指针空值，这在验证 share_ptr 智能指针的有效性会很有作用。例子如下：

```c++
#include <iostream>
#include <memory>
using namespace std;

void Cheak(weak_ptr<int>& wp){
	shared_ptr<int> sp = wp.lock();
	if(sp != nullptr)
		cout<<"still "<<*sp<<endl;
	else
		cout<<"pointer is invalid"<<endl;
}

int main(){
	shared_ptr<int> sp1(new int(22));
	shared_ptr<int> sp2 = sp1;
	weak_ptr<int> wp = sp1;		//指向 shared_ptr<int> 所指对象

	cout<<*sp1<<endl;
	cout<<*sp2<<endl;
	Cheak(wp);

	sp1.reset();
	sp2.reset();

	Cheak(wp);	//pointer is invalid
	return 0;
}
```

#3. 垃圾回收

## 3.1 垃圾回收的分类

垃圾回收的方式可以分为两大类：基于引用计数的垃圾回收器和基于跟踪处理的垃圾回收器。

### 3.1.1 基于引用计数的垃圾回收器

引用计数主要是记录对象被引用（引用、指针）的次数，当对象被引用的次数变为0时，该对象即可被视作“垃圾”而回收。

优点：

- 实现简单
- 与其他回收算法相比，该方法不会造成程序暂停，因为计数的增减与对象的使用是紧密结合的
- 引用计数不会对系统的缓存或者交换空间造成冲击

缺点：

- 难处理“环形引用”的问题
- 计数带来不小的额外开销

### 3.1.2 基于跟踪处理的垃圾回收器

相比于引用计数，跟踪处理的垃圾回收机制被更为广泛地应用。其基本方法是产生跟踪对象的关系图，然后进行垃圾回收。主要有以下方式：

（1）标记-清除（Mark-Sweep）

首先该算法将程序中正在使用的对象视为“根对象”，从根对象开始查找它们所引用的堆空间，并在这些堆空间上做标记。当标记结束后，所有被标记的对象就是可达对象或活对象，而没有被标记的对象就被认为是垃圾对象，在第二步清扫阶段会被回收掉。

这种方法的特点是活的对象不会移动，但是其存在会出现大量的内存碎片。

（2）标记-整理（Mark-Compact）

这个算法标记的方法和标记-清除方法一样，但是标记完之后，不再遍历所有对象清扫垃圾了，而是将活的对象向“左”靠齐，这就解决了内存碎片的问题。

标记-整理的方法有个特点就是移动活的对象，因此相应的，程序中所有对堆内存的引用都必须更新。

（3）标记-拷贝（Mark-Copy）

这种算法将堆空间分为两个部分：From 和 To。刚开始系统只从 From 的堆空间里面分配内存，当 From 分配满的时候就开始垃圾回收：从 From 堆空间找出所有活的对象，拷贝到 To 的堆空间里。这样一来，From 的堆空间里就全剩下垃圾了。而对象被拷贝到 To 里之后，在 To 里是紧凑排列的。接下来是需要将 From 和 To 交换一下角色，接着从新的 From 里面开始分配。

标记-拷贝算法的一个问题是堆的利用率只有一半，而且也需要移动活的对象。

## 3.2 C++与垃圾回收

C++11 支持最小垃圾回收，为此定义了安全派生的指针，安全派生的指针是指向由 new 分配的对象或其子对象的指针。安全派生指针的操作包括：

- 在解引用基础上的引用，比如：&*p
- 定义明确的指针操作，比如：p+1
- 定义明确的指针转换，比如：static_cast<void*>(p)
- 指针和整型之间的 reinterpret_cast

### 参考资料

- 《深入理解C++11：C++11新特性解析与应用》
