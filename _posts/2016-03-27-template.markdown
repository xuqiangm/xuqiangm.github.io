---
title: C++ 模板
date: 2016-03-27
categories: c++
---

本文将从函数模板和类模板来介绍 C++ 模板。本文只是对模板中值得关注的点进行梳理，如果读者需要系统的学习的话，建议还是阅读相关方面的书籍。

首先必须要认识到，模板不会创建任何函数或类，只是告诉编译器如何定义类或函数。

# 1. 函数模板

## 1.1 重载的模板

```c++
template <typename T>
void Swap(T& a, T& b);
template <typename T>
void Swap(T* a, T* b, int n);
void Show(int a[]);
```

上面的代码就出现了三种 Swap 函数的重载。

## 1.2 显式具体化

- 对于给定的函数名。可以有非模板函数，模板函数和显示具体化模板函数以及它们的重载版本。
- 显示具体化的原型和定义应以 template<> 打头，并通过名称来指出类型。
- 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。

下面是用于交换 job 结构的非模板函数、模板函数和具体化的原型：

```c++
//非模板函数
void Swap(job& a, job& b);

//模板函数
template <typename T>
void Swap(T&, T&);

//显式具体化
template <> void Swap<job>(job& , job&);
//或者
template <> void Swap(job& , job&);
```

## 1.3 实例化和具体化

这个部分主要提的是隐式实例化、显式实例化和显式具体化。需要注意的是**试图在同一个文件中使用同一种类型的显式实例化和显式具体化将出错。

下面通过一个例子来说明下隐式实例化、显式实例化和显式具体化。

```c++
//模板原型
template <typename T>
void Swap(T& , T&);			

//显式具体化
template <> void Swap<job>(job& a, job& b);

int main(){
	template void Swap<char>(char&, char&); //显式实例化的一种方式

	short a,b;
	...
	Swap(a,b);		//用 short 实例化模板

	job m,n;
	Swap(m,n);		//使用显式具体化

	char g,h;
	Swap(g,h);		//使用char的显式实例化

	double x;
	double y;
	Swap<double>(x,y);		//显式实例化的另一种形式

	int i;
	double j;
	Swap<double>(i,j);		//error，第一形参的类型为 double&，不能指向 int 变量 i
}
```
# 类模板